{"version":3,"file":"subslate.js","sources":["../src/lib/utils.ts","../src/lib/context.ts","../src/lib/escapes.ts","../src/lib/index.ts"],"sourcesContent":["import { strPairs } from \"./typing\";\n\nexport function iter<F extends (...args:any)=>any>(fn: F, inputs: unknown[],endFn?: CallableFunction): Iterable<ReturnType<F>> {return {\n\t[Symbol.iterator]() {return {\n\t\tnext() {\n\t\t\tconst result = fn(...inputs)\n\t\t\tif (result) {\n\t\t\t\treturn {done: false, value: result};\n\t\t\t}\n\t\t\tif (endFn) endFn();\n\t\t\treturn {done: true, value: undefined};\n\t\t}\n\t}}\n}}\nconst isNonEmptyArray = (v: unknown): v is unknown[] => Array.isArray(v) && v.length > 0\nconst isStrArr = (v: unknown): v is strPairs => isNonEmptyArray(v) && v.length === 2 && v.every(x => typeof x === 'string');\nconst isArrStrArr = (v: unknown): v is strPairs[] => isNonEmptyArray(v) && v.every(x => isStrArr(x))\nexport const defaulted = (v: unknown,d: strPairs,errMsg='Missing Provided Input'): strPairs[] => {\n\tif (typeof v === 'undefined') return [d];\n\tif (typeof v === 'string') return [[v,v]];\n\tif (isStrArr(v)) return [v];\n\tif (isArrStrArr(v)) return v;\n\tthrow Error(errMsg)\n}\nexport function escapeRegExp(text:string) {\n\treturn text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\nexport function regReset(reg: RegExp) {\n\treg.lastIndex = 0;\n}\n\n","import { ContextOptions, cacheObj } from \"./typing\";\nimport { escapeRegExp } from \"./utils\";\n\ntype sepNames = 'per' | 'opBrac' | 'clBrac' | 'quote' | 'apos' | 'backt'\ntype separators = {\n\t[K in sepNames]: string[];\n}\n\nconst isBlank = Symbol('Blank Value')\nexport class Context {\n\tcontext: object;\n\tconstructor (context: object){\n\t\tthis.context = context;\n\t}\n\tgetContextVal(item: cacheObj,separators: separators, options:ContextOptions) {\n\t\tconst id = item.content;\n\t\tconst con = this.context;\n\t\tconst {allowRootBracket,allowUnquotedProps,sanitizer} =options\n\t\tconst {per,opBrac,clBrac,quote,apos,backt} = separators;\n\t\tconst quotes = [quote,apos,backt].flat().filter(v => id.includes(v)).map(v => escapeRegExp(v));\n\n\t\tfunction getRelative (funId: string, localContext: object, startIndex = 0): [symbol|unknown,number]{\n\t\t\tlet result = isBlank;\n\t\t\tlet foundLength = 0;\n\t\t\tconst base = Object.keys(localContext)\n\t\t\tFindRoot: {\n\t\t\t\tif (startIndex === 0) {\n\t\t\t\t\tfor (const rootKey of base) {\n\t\t\t\t\t\tif (funId.startsWith(rootKey,startIndex)) {\n\t\t\t\t\t\t\tresult = localContext[rootKey]\n\t\t\t\t\t\t\tfoundLength = rootKey.length;\n\t\t\t\t\t\t\tbreak FindRoot;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIndex !== 0) {\n\t\t\t\t\tfor (const period of per) {\n\t\t\t\t\t\tif (funId.startsWith(period,startIndex)) {\n\t\t\t\t\t\t\tfor (const rootKey of base) {\n\t\t\t\t\t\t\t\tif (funId.startsWith(period + rootKey,startIndex)) {\n\t\t\t\t\t\t\t\t\tresult = localContext[rootKey]\n\t\t\t\t\t\t\t\t\tfoundLength = period.length + rootKey.length;\n\t\t\t\t\t\t\t\t\tbreak FindRoot;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIndex !== 0 || allowRootBracket) {\n\t\t\t\t\tconst filteredBrackets = opBrac.map((v,i) => [v,clBrac[i]]).filter(v => funId.includes(v[0]) && funId.includes(v[1]))\n\t\t\t\t\tlet currentBrackets: [string,string] = null;\n\t\t\t\t\tfor (const [open, close] of filteredBrackets) {\n\t\t\t\t\t\tif (funId.startsWith(open,startIndex)) {\n\t\t\t\t\t\t\tcurrentBrackets = [open, close];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (currentBrackets === null) break FindRoot;\n\t\t\t\t\tconst [open, close] = currentBrackets.map(v => escapeRegExp(v));\n\t\t\t\t\tfor (const quote of [...quotes,...(allowUnquotedProps ? [''] : [])]) {\n\t\t\t\t\t\tfor (const rk of base) {\n\t\t\t\t\t\t\tconst rootKey = escapeRegExp(rk);\n\t\t\t\t\t\t\tconst getInnerReg = RegExp(`^[\\\\s\\\\S]{${startIndex}}(${open}\\s*${quote}(${rootKey})${quote}\\s*${close})`)\n\t\t\t\t\t\t\tgetInnerReg.lastIndex = startIndex;\n\t\t\t\t\t\t\tconst match = getInnerReg.exec(id);\n\t\t\t\t\t\t\tif (match && match[2]) {\n\t\t\t\t\t\t\t\tresult = localContext[rk];\n\t\t\t\t\t\t\t\tfoundLength = match[1].length;\n\t\t\t\t\t\t\t\tbreak FindRoot;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [result,foundLength];\n\t\t}\n\t\tlet finResult: typeof isBlank | unknown = isBlank;\n\n\t\tlet curInd = 0;\n\t\tfor (;curInd < id.length;) {\n\t\t\tconst localContext = finResult === isBlank ? con : finResult;\n\t\t\tif (typeof localContext !== 'object') break;\n\t\t\tconst [newfinResult,foundLength] = getRelative(id,localContext,curInd);\n\t\t\tif (foundLength === 0) break;\n\t\t\tcurInd += foundLength;\n\t\t\tfinResult = newfinResult;\n\t\t}\n\n\t\tif (finResult === isBlank) {\n\t\t\tfinResult = sanitizer({\n\t\t\t\tisEmpty: true,\n\t\t\t\tid,\n\t\t\t\tat: curInd,\n\t\t\t})\n\t\t} else {\n\t\t\tfinResult = sanitizer({\n\t\t\t\tisEmpty: false,\n\t\t\t\tvalue: finResult,\n\t\t\t\tid,\n\t\t\t})\n\t\t}\n\t\tif (typeof finResult !== 'string') throw Error('Sanitizer did not provide string')\n\t\treturn finResult;\n\t}\n}\n\n","import { EscapeTypeFlags, escapeNames} from \"./typing\";\n\nconst JS_DICT = {\n\t'\\'': '\\'',\n\t'\"': '\\\"',\n\t'\\\\': '\\\\',\n\t'`':'\\`',\n\t'[':'\\[',\n\t']':'\\]',\n}\nconst jsonDef = (v: string) => JS_DICT[v] || v;\nconst HTML_DICT = {\n\t'.': [\"&period;\"],\n\t'\\\\':[\"&#x27;\"],\n\t'\\'': [\"&apos;\"],\n\t'\\\"': [\"&quot;\"],\n\t'[': [\"&lsqb;\"],\n\t']': [\"&rsqb;\"],\n}\nconst htmlDef = (v: string) => HTML_DICT[v] || v;\nconst toJsUni = (code: number) => `\\\\u${Number.prototype.toString.call(code,16).toUpperCase()}`;\nconst toHTMLUni = (code: number) => `&#x${Number.prototype.toString.call(code,16).toUpperCase()};`;\nconst getUnicode = (str: string,type: 'js' | 'html') => [...str].map(v => v.split('').map(x => ({\n\t\tjs: toJsUni,\n\t\thtml: toHTMLUni\n\t}[type](String.prototype.charCodeAt.call(x,0)))).join('')).join('')\n\nexport const toEscapes: {\n\t[K in escapeNames]: (str: string) => string[];\n} = {\n\turl: (str: string) => [encodeURIComponent(str)],\n\thtml: (str: string) => [[...str].map(v => getUnicode(v,'html')).join(''),[...str].map(v => htmlDef(v)).join('')],\n\tjs: (str: string) => [[...str].map(v => jsonDef(v)).join(''),[...str].map(v => getUnicode(v,'js')).join('')],\n\tjson: (str: string) => [[...str].map(v => jsonDef(v)).join(''),[...str].map(v => getUnicode(v,'js')).join('')],\n}\n\nexport const toAllEscapes = (identifier: string, flags: EscapeTypeFlags): string[] => {\n\tconst escaped = new Set<string>();\n\tfor (let k in flags) {\n\t\tif (toEscapes[k]) toEscapes[k](identifier).forEach((v:string) => escaped.add(v))\n\t}\n\treturn Array.from(escaped);\n}\n\n","import { Context } from \"./context\";\nimport { toAllEscapes } from \"./escapes\";\nimport { Options,cacheObj, strPairs } from \"./typing\";\nimport { iter, defaulted,regReset, escapeRegExp } from \"./utils\";\ninterface DefaultedOptions extends Options {\n\tstartStopPairs: strPairs[]\n}\nexport const getDefaultOptions = (options: Partial<Options>): DefaultedOptions => ({\n\tstartStopPairs: defaulted(options.startStopPairs,['${','}'],'Invalid startStopPairs'),\n\tescapeSep: options.escapeSep,\n\tallowUnquotedProps: !!options.allowUnquotedProps,\n\tallowRootBracket: !!options.allowRootBracket,\n\tsanitizer: options.sanitizer || ((v) =>\n\t\tv.isEmpty === true ? 'undefined' : String(v.value)),\n\tmaxNameLength: options.maxNameLength || 256,\n})\nexport const createEscapes = toAllEscapes;\nexport const getSeparators = (escapeSep: Options['escapeSep']) => {\n\tconst [per,opBrac,clBrac,quote,apos,backt] = ['.','[',']','\"',\"'\",'`'].map(v => escapeSep ? toAllEscapes(v,escapeSep): [v])\n\tconst separators = {per,opBrac,clBrac,quote,apos,backt};\n\treturn separators;\n}\n\nexport const subslate = (text: string,context: object, options?: Partial<Options> | undefined): string => {\n\tconst defaultedOptions = getDefaultOptions(options);\n\tconst {\n\t\tstartStopPairs,\n\t\tescapeSep,\n\t\tmaxNameLength,\n\t} = defaultedOptions\n\tconst filteredPairs = startStopPairs.filter(v => text.includes(v[0]) && text.includes(v[1])).map(v =>\n\t\t[escapeRegExp(v[0]),escapeRegExp(v[1])]);\n\tconst cache = new Map<string,cacheObj>();\n\tfor (const [startStr,endStr] of filteredPairs) {\n\t\tconst searcher = RegExp(`${startStr}\\s*([\\\\s\\\\S]{0,${maxNameLength}}?)\\s*${endStr}`,'g')\n\t\tconst reset = () => regReset(searcher)\n\t\tconst execSearcher = () => searcher.exec(text);\n\t\tfor (const {index, 0: match, 1: content} of iter(execSearcher,[],reset)) {\n\t\t\tif(!cache.has(match)) {\n\t\t\t\tcache.set(match, {\n\t\t\t\t\tcontent,\n\t\t\t\t\tindexes: [index]\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tlet temp = cache.get(match);\n\t\t\t\ttemp.indexes.push(index);\n\t\t\t}\n\t\t}\n\t}\n\tconst lContext = new Context(context)\n\tlet indexOffset = 0;\n\tconst localStr = [...text];\n\tconst separators = getSeparators(escapeSep)\n\tfor (const [match, item] of cache) {\n\t\tif (!item.hasOwnProperty('value')) {\n\t\t\titem.value = lContext.getContextVal(item,separators,defaultedOptions)\n\t\t}\n\t\tfor (const ind of item.indexes) {\n\t\t\tlocalStr.splice(ind + indexOffset,match.length, ...item.value)\n\t\t\tindexOffset += (item.value.length - match.length);\n\t\t}\n\t}\n\treturn localStr.join('');\n}\nexport default subslate;\n"],"names":["iter","fn","inputs","endFn","Symbol","iterator","[object Object]","result","done","value","undefined","isNonEmptyArray","v","Array","isArray","length","isStrArr","every","x","defaulted","d","errMsg","isArrStrArr","Error","escapeRegExp","text","replace","isBlank","Context","context","item","separators","options","id","content","con","this","allowRootBracket","allowUnquotedProps","sanitizer","per","opBrac","clBrac","quote","apos","backt","quotes","flat","filter","includes","map","getRelative","funId","localContext","startIndex","foundLength","base","Object","keys","FindRoot","rootKey","startsWith","period","filteredBrackets","i","currentBrackets","open","close","rk","getInnerReg","RegExp","lastIndex","match","exec","finResult","curInd","newfinResult","isEmpty","at","JS_DICT","jsonDef","HTML_DICT","toJsUni","code","Number","prototype","toString","call","toUpperCase","toHTMLUni","getUnicode","str","type","split","js","html","String","charCodeAt","join","toEscapes","url","encodeURIComponent","htmlDef","json","toAllEscapes","identifier","flags","escaped","Set","k","forEach","add","from","getDefaultOptions","startStopPairs","escapeSep","maxNameLength","createEscapes","getSeparators","subslate","defaultedOptions","filteredPairs","cache","Map","startStr","endStr","searcher","reset","execSearcher","index","has","get","indexes","push","set","lContext","indexOffset","localStr","hasOwnProperty","getContextVal","ind","splice"],"mappings":"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"}